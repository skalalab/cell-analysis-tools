from skimage.measure import regionprops
from skimage.morphology import label
import numpy.ma as ma
import numpy as np
from flim_tools.io import read_asc
import tifffile
from pprint import pprint
from flim_tools.image_processing import normalize

import matplotlib.pylab as plt
import matplotlib as mpl
mpl.rcParams["figure.dpi"] = 300
import math

#%%
def regionprops_omi(
                    image_id, # base_name of image
                    label_image,
                    im_nadh_intensity,
                    im_nadh_a1, 
                    im_nadh_a2, 
                    im_nadh_t1, 
                    im_nadh_t2,
                    im_fad_intensity,
                    im_fad_a1,
                    im_fad_a2,
                    im_fad_t1,
                    im_fad_t2,
                    ):
    """
    Takes in labels image as well as nadh and fad images to return
    mean and stdev of each parameter per roi

    Parameters
    ----------
    label_image : ndarray
        labeled mask image.
    im_nadh_intensity : ndarray
        nadh intensity image.
    im_nadh_a1 : ndarray
        nadh alpha1 image.
    im_nadh_a2 : ndarray
        nadh alpha2 image .
    im_nadh_t1 : ndarray
        nadh tau 1 lifetime, short .
    im_nadh_t2 : ndarray
        nadh tau 2 lifetime, long.
    im_fad_intensity : ndarray
        nadh intensty image. 
    im_fad_a1 : ndarray
        fad alpha 1 image. 
    im_fad_a2 : ndarray
        fad alpha 2 image. 
    im_fad_t1 : ndarray
        fad tau 1 lifetime, long. 
    im_fad_t2 : ndarray
        fad tau 2 lifetime, short. 
     
    Returns
    -------
    dict
        dictionary of mean and standard deviations of 
        omi parameters for each region.

    """
    pass
    # 1. nadh_intensity
    # 2. nadh_a1
    # 3. nadh_a2
    # 4. nadh_t1
    # 5. nadh_t2
    # 6. nadh_tau_mean
    # 7. fad_intensity
    # 8. fad_a1
    # 9. fad_a2
    # 10. fad_t1
    # 11. fad_t2
    # 12. fad_tau_mean
    # 13. redox_ratio

    # compute composite images not generated by SPCImage
    # convert a1/a2 to percent
    im_nadh_tau_mean = (im_nadh_a1/100 * im_nadh_t1) + (im_nadh_a2/100 * im_nadh_t2)
    im_fad_tau_mean = (im_fad_a1/100 * im_fad_t1) + (im_fad_a2/100 * im_fad_t2)
    
    # mask and apply redox ratio
    labels_inverted= np.invert(label_image.astype(bool))
    masked_im_fad_intensity = ma.masked_array(im_fad_intensity, mask=labels_inverted)
    masked_im_nadh_intensity = ma.masked_array(im_nadh_intensity, mask=labels_inverted)
    im_redox_ratio = masked_im_nadh_intensity / masked_im_fad_intensity
    
    # fluorescence lifetime imaging redox ratio aka FLIRR
    # labels mask image should not include any im_fad_a1 zeros
    # because it has been revised in main.py.
    # apply mask then compute to avoid Infinite values
    masked_im_fad_a1 = ma.masked_array(im_fad_a1, mask=labels_inverted)
    masked_im_nadh_a2 = ma.masked_array(im_nadh_a2, mask=labels_inverted)
    im_flirr = (masked_im_nadh_a2/100) / (masked_im_fad_a1/100) # bound portions of NADH/FAD

    
    # print("regionprops_omi: currently setting FLIRR INF values to zero")
    # print("remove this message once FLIRR or mask computation has been updated")
    # im_flirr[im_flirr == np.Inf] = 0
    
    # DEFINE EXTRA PROPERTIES
    def stdev(roi, intensity):
        inverted_roi = np.invert(roi.astype(bool))
        masked_image = ma.masked_array(intensity, mask=inverted_roi)
        return np.std(masked_image)

    extra_properties = [stdev]
    
    # EQUALLY WEIGHTED PARAMETERS
    nadh_intensity = regionprops(label_image, im_nadh_intensity, extra_properties=extra_properties)
    nadh_a1 = regionprops(label_image, im_nadh_a1, extra_properties=extra_properties)
    nadh_a2 = regionprops(label_image, im_nadh_a2, extra_properties=extra_properties)
    nadh_t1 = regionprops(label_image, im_nadh_t1, extra_properties=extra_properties)
    nadh_t2 = regionprops(label_image, im_nadh_t2, extra_properties=extra_properties)
    nadh_tau_mean = regionprops(label_image, im_nadh_tau_mean, extra_properties=extra_properties)
    fad_intensity = regionprops(label_image, im_fad_intensity, extra_properties=extra_properties)
    fad_a1 = regionprops(label_image, im_fad_a1, extra_properties=extra_properties)
    fad_a2 = regionprops(label_image, im_fad_a2, extra_properties=extra_properties)
    fad_t1 = regionprops(label_image, im_fad_t1, extra_properties=extra_properties)
    fad_t2 = regionprops(label_image, im_fad_t2, extra_properties=extra_properties)
    fad_tau_mean = regionprops(label_image, im_fad_tau_mean, extra_properties=extra_properties)
    redox_ratio = regionprops(label_image, im_redox_ratio, extra_properties=extra_properties)
    flirr = regionprops(label_image, im_flirr, extra_properties=extra_properties)

    dict_regionprops = {
        "nadh_intensity" : nadh_intensity,
        "nadh_a1" : nadh_a1,
        "nadh_a2" : nadh_a2,
        "nadh_t1" : nadh_t1,
        "nadh_t2" : nadh_t2,
        "nadh_tau_mean" : nadh_tau_mean,
        "fad_intensity" : fad_intensity,
        "fad_a1" : fad_a1,
        "fad_a2" : fad_a2,
        "fad_t1" : fad_t1,
        "fad_t2" : fad_t2,
        "fad_tau_mean" : fad_tau_mean,
        "redox_ratio" : redox_ratio,
        "flirr" : flirr
        }
    

        
     # image_lifetime * image_intensity pixels /image_intensity.max() * (np.sum(roi_intensity)/ num_pixels)  
    # assemble dictionary of omi parameters
    dict_omi = {}
    for rp_key in dict_regionprops.keys():# iterate through each images regionprops
        for region in dict_regionprops[rp_key]: # iterate through region in regionprops
            pass
            dict_key_name = f"{image_id}_{region.label}" # generate unique key for region in this image
            if not dict_key_name in dict_omi.keys(): # add region dict if needed
                pass
                dict_omi[dict_key_name] = {} # add new dict for this label
                dict_omi[dict_key_name]["mask_label"] = int(region.label) # save label value
            
            # save equally weighted parameters
            dict_omi[dict_key_name][f"{rp_key}_mean"] = region.mean_intensity
            dict_omi[dict_key_name][f"{rp_key}_stdev"] = region.stdev
                
            ### COMPUTE INTENSITY WEIGHTED VALUES
            list_valid_intensity_weights = [
                        "nadh_a1", 
                        "nadh_a2",
                        "nadh_t1", 
                        "nadh_t2",
                        "nadh_tau_mean",
                        "fad_a1",
                        "fad_a2",
                        "fad_t1",
                        "fad_t2",
                        "fad_tau_mean"
                    ]

                    
            # Compute the intensity weighted values
            print(f"{rp_key=}")
            if rp_key in list_valid_intensity_weights: # one of the valid lifetime images
                
                # select proper intensity image to weigh by
                if "fad" in rp_key:
                    im_intensity_region = [r for r in fad_intensity if r.label == region.label][0] # should be one region
                    
                elif "nadh" in rp_key:
                    im_intensity_region = [r for r in nadh_intensity if r.label == region.label][0] # should be one region
                
                # gather other things needed for intensity weighte
                binary = region.image
                inverted_binary = np.invert(binary)
                
                im_lifetime_masked = ma.masked_array(region.intensity_image, mask=inverted_binary)
                im_intensity_masked = ma.masked_array(im_intensity_region.intensity_image, mask=inverted_binary)

                
                im_intensity_weighted = (im_lifetime_masked * im_intensity_masked) / np.sum(im_intensity_masked)
                intensity_weighted_mean = np.sum(im_lifetime_masked * im_intensity_masked) / np.sum(im_intensity_masked)
                
                 # https://stackoverflow.com/questions/2413522/weighted-standard-deviation-in-numpy
                def weighted_avg_and_std(values, weights):
                    """
                    Return the weighted average and standard deviation.
                    values, weights -- Numpy ndarrays with the same shape.
                    """
                    average = np.average(values, weights=weights)
                    # Fast and numerically precise:
                    variance = np.average((values-average)**2, weights=weights)
                    return (average, math.sqrt(variance))
                
                weighted_mean, weighted_stdev = weighted_avg_and_std(im_lifetime_masked, im_intensity_masked)
                print(f"{weighted_mean=} | {intensity_weighted_mean=}")
                assert weighted_mean ==intensity_weighted_mean
                    
                # save values
                dict_omi[dict_key_name][f"{rp_key}_intensity_weighted_mean"] = intensity_weighted_mean
                dict_omi[dict_key_name][f"{rp_key}_intensity_weighted_stdev"] = weighted_stdev
                
                if region.label == 10:
                    fig, ax = plt.subplots(1,4, figsize=(10,3))
                    
                    fig.suptitle(f"{rp_key}")
                    # original intensity
                    ax[0].set_title(f"intensity\n total photons: {np.sum(im_intensity_masked)}")
                    ax[0].imshow(im_intensity_masked)
                    ax[0].set_axis_off()
                    
                    # binary
                    ax[1].set_title("binary")
                    ax[1].imshow(binary)
                    ax[1].set_axis_off()
                    
                    # equally weighted 
                    ax[2].set_title(f"equally weighted \n "\
                                    f'mean: {dict_omi[dict_key_name][f"{rp_key}_mean"]:.3f} \n' \
                                    f'stdev : {dict_omi[dict_key_name][f"{rp_key}_stdev"]:.3f}' \
                                        )
                    ax[2].imshow(im_lifetime_masked)
                    ax[2].set_axis_off()
                    
                    # intensity weighted
                    ax[3].set_title(f"intensity weighted lifetime \n"\
                                    f'mean: {dict_omi[dict_key_name][f"{rp_key}_intensity_weighted_mean"]:.3f} \n' \
                                    f'stdev: {dict_omi[dict_key_name][f"{rp_key}_intensity_weighted_stdev"]:.3f}'
                                    )
                    ax[3].imshow(im_intensity_weighted)
                    ax[3].set_axis_off()
                    plt.show()


    # dictionary of omi features could be df if we wanted to
    return dict_omi
#%%

if __name__ == "__main__":
    
    from pathlib import Path
    import pandas as pd
    path_dictionaries = Path(r"Z:\0-Projects and Experiments\RD - redox_ratio_development\Data Combined + QC Complete\0-dictionaries")
    
    list_csv_files = list(path_dictionaries.glob("*"))

    csv_dict =  pd.read_csv(list_csv_files[0])   
    csv_dict.index.name = "base_name"
    
    test_dict = csv_dict.iloc[0]
    
    def load_image(path):
        # detects extension and loads image accordingly
        # tif/tiff vs asc
        pass
        if path.suffix == ".asc":
            return read_asc(path)
        if path.suffix in [".tiff", ".tif"]:
            return tifffile.imread(path)
#%%

    omi_props = regionprops_omi(
        image_id="test_image",
        label_image = load_image(Path(test_dict.mask_cell)),
        im_nadh_intensity = load_image(Path(test_dict.nadh_photons)),
        im_nadh_a1 = load_image(Path(test_dict.nadh_a1)),
        im_nadh_a2 = load_image(Path(test_dict.nadh_a2)),
        im_nadh_t1 = load_image(Path(test_dict.nadh_t1)),
        im_nadh_t2 = load_image(Path(test_dict.nadh_t2)),
        im_fad_intensity = load_image(Path(test_dict.fad_photons)),
        im_fad_a1 = load_image(Path(test_dict.fad_a1)),
        im_fad_a2 = load_image(Path(test_dict.fad_a2)),
        im_fad_t1 = load_image(Path(test_dict.fad_t1)),
        im_fad_t2 = load_image(Path(test_dict.fad_t2)),
        )    
    
    pprint(omi_props)
    df = pd.DataFrame(omi_props).transpose()
